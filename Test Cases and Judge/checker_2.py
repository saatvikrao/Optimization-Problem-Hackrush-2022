import re
from tqdm import tqdm
# Start of BODY
'''
TestStruct::
testcase_id                   [int] ID of the test-case
testcase_input_path           [str] File path to test-case input
testcase_output_path          [str] File path to test-case output generated by the problem solver
testcase_expected_output_path [str] File path to test-case expected output to be matched with
testcase_error_path           [str] File path to test-case STDERR
metadata_file_paths           [list<str>] File paths to Question metadata (Extra files usually used for defining traning sets)
submission_code_path          [str] File path to submission source code
submission_language           [str] Language token of submission
testcase_result               [bool] Set to True if test-case output matches test-case expected output. Matching is done line by line
testcase_signal               [int] Exit code of the test-case process
testcase_time                 [float] Time taken by the test-case process in seconds
testcase_memory               [int] Peak memory of the test-case process determined in bytes
data                          [str] <Future use>
ResultStruct::
result      [bool]  Assign test-case result. True determines success. False determines failure
score       [float] Assign test-case score. Normalized between 0 to 1
message     [str] Assign test-case message. This message is visible to the problem solver
'''

def cost_function(s,area):
    return 100*s*s + 0.7*area

def dfs(node,adj,blown):
    blown[node] = 1
    stack = [node]
    while stack:
        vertex = stack.pop()
        blown[vertex] = 1
        for i in adj[vertex]:
            if blown[i]!=1:
                stack.append(i)

result_data = ''
try:
    result_data = open("input.txt", 'r').read()               #this is path of output generated by your Code
except IOError:
    quit()
# Read contents of the result file
values = re.split('\n', result_data)

No_Jammers = int(values[0])

jammers = []
for i in range(No_Jammers):
    jammers.append([float(j) for j in values[i+1].split()])

input_data=''
input_data = open("input/5.txt", 'r').read()                  #this is path of the test case
input_values = re.split('\n', input_data)

n,r=[int(i) for i in input_values[0].split()]

bombs = []
for i in range(n):
    bombs.append([int(j) for j in input_values[i+1].split()])             

blown = [0 for i in range(n)]

adj = {}
for i in range(n):
    adj[i] = []

for i in tqdm(range(n)):
    for j in range(i+1,n):
        dist = pow((bombs[i][0]-bombs[j][0])**2 + (bombs[i][1]-bombs[j][1])**2,0.5)
        if(dist <= bombs[i][2]):
            adj[i].append(j)
        if(dist <= bombs[j][2]):
            adj[j].append(i)

    
area = 0
for i in tqdm(range(n)):
    blown[i] = 1
    for j in jammers:
        dist = pow((bombs[i][0]-j[0])**2 + (bombs[i][1]-j[1])**2,0.5)
        if(dist <= r):
            blown[i]=0
            break

for i in range(n):
    if(blown[i] == 1):
        dfs(i,adj,blown)

for i in range(n):
    if blown[i]==1:
        area += 3.14 * (bombs[i][2]**2)
c = cost_function(No_Jammers,area)

print(c)
   

    # Cutoff score to determine success
    
    # r_obj.score = c
    # r_obj.message = str(c)

        
